// Generated by CoffeeScript 1.7.1
var CSSLint, async, port, r, request, rules, servers, type, validateCSS, zombie, _fn, _i, _len;

async = require("async");

request = require("request");

zombie = require("zombie");

CSSLint = require("csslint").CSSLint;

rules = CSSLint.getRules().filter(function(rule) {
  return rule.id === "errors";
});

CSSLint.clearRules();

for (_i = 0, _len = rules.length; _i < _len; _i++) {
  r = rules[_i];
  CSSLint.addRule(r);
}

validateCSS = CSSLint.verify;

servers = {
  development: 7000,
  production: 7001
};

_fn = function(type, port) {
  var fetchPage;
  fetchPage = function(path) {
    return function(done) {
      this.browser = new zombie.Browser();
      this.httpRoot = "http://localhost:" + port;
      this.browser.visit(this.httpRoot + path).then(function() {
        done();
      }, function(err) {
        done(err);
      });
    };
  };
  describe("JS assets in " + type + " server", function() {
    before(fetchPage("/"));
    it("Can share plain js files from fs", function() {
      return expect(this.browser.window["js fs"]).to.equal(true);
    });
    it("can share raw js strings", function() {
      return expect(this.browser.window["raw js"]).to.equal(true);
    });
    it("has no namespaced raw js here", function() {
      return expect(this.browser.window["raw namespace js"]).to.be.an('undefined');
    });
    it("Coffee script files get compiled transparently", function() {
      return expect(this.browser.window["coffee fs"]).to.equal(true);
    });
    it("addOb adds global variables", function() {
      return expect(this.browser.window["addOb global"]).to.equal(true);
    });
    it("addOb does not override namespace objects", function() {
      expect(this.browser.window.namespaceob.second).to.equal(true, "second addOb missing");
      return expect(this.browser.window.namespaceob.first).to.equal(true, "first addOb missing");
    });
    it("js.addExec gets executed", function() {
      return expect(this.browser.window["js exec"]).to.equal(true);
    });
    it("addUrl can load assets from remote servers", function() {
      return expect(this.browser.window["remote script"]).to.equal(true);
    });
    return it("No namespaced js here", function() {
      return expect(this.browser.window["namespace"]).to.be.an('undefined');
    });
  });
  describe("Namespaced JS assets in " + type + " server", function() {
    before(fetchPage("/namespace"));
    it("We have namaspaced js here", function() {
      return expect(this.browser.window["namespace"]).to.equal(true);
    });
    it("We have also global js", function() {
      return expect(this.browser.window["js fs"]).to.equal(true);
    });
    it("namespaced js.addExec gets executed", function() {
      return expect(this.browser.window["namespace js exec"]).to.equal(true);
    });
    return it("can share raw js strings in namespaces", function() {
      return expect(this.browser.window["raw namespace js"]).to.equal(true);
    });
  });
  return describe("CSS assets in " + type + " server", function() {
    before(fetchPage("/"));
    it("We have css links", function() {
      var $;
      $ = this.browser.window.jQuery;
      return expect($("link[rel='stylesheet']").size()).to.be.above(0);
    });
    return it("has valid CSS", function(done) {
      var $, cssUrls;
      $ = this.browser.window.jQuery;
      cssUrls = $("link[rel='stylesheet']").map(function() {
        return this.href;
      });
      return async.reduce(cssUrls, "", (function(_this) {
        return function(memo, path, cb) {
          return request(_this.httpRoot + path, function(err, res, body) {
            expect(res.statusCode).to.be(200, "" + path + " is missing");
            if (err) {
              return cb(err);
            }
            return cb(null, memo + body);
          });
        };
      })(this), function(err, css) {
        var result;
        expect(err).to.not.be.ok();
        result = validateCSS(css, rules);
        expect(result.messages.length).to.be(0, "" + (util.inspect(result.messages)));
        return done();
      });
    });
  });
};
for (type in servers) {
  port = servers[type];
  _fn(type, port);
}
